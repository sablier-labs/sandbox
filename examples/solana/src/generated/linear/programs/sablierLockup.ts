/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type Address,
  type ReadonlyUint8Array,
} from '@solana/kit';
import {
  type ParsedCancelInstruction,
  type ParsedCollectFeesInstruction,
  type ParsedCreateWithDurationsLlInstruction,
  type ParsedCreateWithTimestampsLlInstruction,
  type ParsedInitializeInstruction,
  type ParsedRefundableAmountOfInstruction,
  type ParsedRenounceInstruction,
  type ParsedStatusOfInstruction,
  type ParsedStreamedAmountOfInstruction,
  type ParsedStreamExistsInstruction,
  type ParsedTreasuryViewInstruction,
  type ParsedWithdrawableAmountOfInstruction,
  type ParsedWithdrawalFeeInLamportsInstruction,
  type ParsedWithdrawInstruction,
  type ParsedWithdrawMaxInstruction,
} from '../instructions';

export const SABLIER_LOCKUP_PROGRAM_ADDRESS =
  '4EauRKrNErKfsR4XetEZJNmvACGHbHnHV4R5dvJuqupC' as Address<'4EauRKrNErKfsR4XetEZJNmvACGHbHnHV4R5dvJuqupC'>;

export enum SablierLockupAccount {
  NftCollectionData,
  StreamData,
  Treasury,
}

export function identifySablierLockupAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): SablierLockupAccount {
  const data = 'data' in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([159, 26, 37, 150, 44, 84, 171, 172])
      ),
      0
    )
  ) {
    return SablierLockupAccount.NftCollectionData;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([61, 89, 148, 141, 154, 81, 86, 113])
      ),
      0
    )
  ) {
    return SablierLockupAccount.StreamData;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([238, 239, 123, 238, 89, 1, 168, 253])
      ),
      0
    )
  ) {
    return SablierLockupAccount.Treasury;
  }
  throw new Error(
    'The provided account could not be identified as a sablierLockup account.'
  );
}

export enum SablierLockupInstruction {
  Cancel,
  CollectFees,
  CreateWithDurationsLl,
  CreateWithTimestampsLl,
  Initialize,
  RefundableAmountOf,
  Renounce,
  StatusOf,
  StreamExists,
  StreamedAmountOf,
  TreasuryView,
  Withdraw,
  WithdrawMax,
  WithdrawableAmountOf,
  WithdrawalFeeInLamports,
}

export function identifySablierLockupInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): SablierLockupInstruction {
  const data = 'data' in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([232, 219, 223, 41, 219, 236, 220, 190])
      ),
      0
    )
  ) {
    return SablierLockupInstruction.Cancel;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([164, 152, 207, 99, 30, 186, 19, 182])
      ),
      0
    )
  ) {
    return SablierLockupInstruction.CollectFees;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([87, 17, 170, 167, 156, 152, 169, 61])
      ),
      0
    )
  ) {
    return SablierLockupInstruction.CreateWithDurationsLl;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([150, 165, 147, 28, 68, 41, 48, 41])
      ),
      0
    )
  ) {
    return SablierLockupInstruction.CreateWithTimestampsLl;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([175, 175, 109, 31, 13, 152, 155, 237])
      ),
      0
    )
  ) {
    return SablierLockupInstruction.Initialize;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([160, 136, 114, 120, 234, 178, 146, 58])
      ),
      0
    )
  ) {
    return SablierLockupInstruction.RefundableAmountOf;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([241, 157, 138, 210, 8, 235, 187, 123])
      ),
      0
    )
  ) {
    return SablierLockupInstruction.Renounce;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([90, 214, 253, 237, 126, 236, 132, 237])
      ),
      0
    )
  ) {
    return SablierLockupInstruction.StatusOf;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([104, 209, 104, 97, 122, 35, 165, 195])
      ),
      0
    )
  ) {
    return SablierLockupInstruction.StreamExists;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([91, 69, 219, 48, 189, 26, 13, 33])
      ),
      0
    )
  ) {
    return SablierLockupInstruction.StreamedAmountOf;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([247, 160, 213, 237, 247, 121, 164, 82])
      ),
      0
    )
  ) {
    return SablierLockupInstruction.TreasuryView;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([183, 18, 70, 156, 148, 109, 161, 34])
      ),
      0
    )
  ) {
    return SablierLockupInstruction.Withdraw;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([32, 71, 46, 98, 105, 76, 85, 96])
      ),
      0
    )
  ) {
    return SablierLockupInstruction.WithdrawMax;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([30, 195, 140, 141, 173, 123, 253, 60])
      ),
      0
    )
  ) {
    return SablierLockupInstruction.WithdrawableAmountOf;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([55, 255, 88, 224, 223, 23, 97, 140])
      ),
      0
    )
  ) {
    return SablierLockupInstruction.WithdrawalFeeInLamports;
  }
  throw new Error(
    'The provided instruction could not be identified as a sablierLockup instruction.'
  );
}

export type ParsedSablierLockupInstruction<
  TProgram extends string = '4EauRKrNErKfsR4XetEZJNmvACGHbHnHV4R5dvJuqupC',
> =
  | ({
      instructionType: SablierLockupInstruction.Cancel;
    } & ParsedCancelInstruction<TProgram>)
  | ({
      instructionType: SablierLockupInstruction.CollectFees;
    } & ParsedCollectFeesInstruction<TProgram>)
  | ({
      instructionType: SablierLockupInstruction.CreateWithDurationsLl;
    } & ParsedCreateWithDurationsLlInstruction<TProgram>)
  | ({
      instructionType: SablierLockupInstruction.CreateWithTimestampsLl;
    } & ParsedCreateWithTimestampsLlInstruction<TProgram>)
  | ({
      instructionType: SablierLockupInstruction.Initialize;
    } & ParsedInitializeInstruction<TProgram>)
  | ({
      instructionType: SablierLockupInstruction.RefundableAmountOf;
    } & ParsedRefundableAmountOfInstruction<TProgram>)
  | ({
      instructionType: SablierLockupInstruction.Renounce;
    } & ParsedRenounceInstruction<TProgram>)
  | ({
      instructionType: SablierLockupInstruction.StatusOf;
    } & ParsedStatusOfInstruction<TProgram>)
  | ({
      instructionType: SablierLockupInstruction.StreamExists;
    } & ParsedStreamExistsInstruction<TProgram>)
  | ({
      instructionType: SablierLockupInstruction.StreamedAmountOf;
    } & ParsedStreamedAmountOfInstruction<TProgram>)
  | ({
      instructionType: SablierLockupInstruction.TreasuryView;
    } & ParsedTreasuryViewInstruction<TProgram>)
  | ({
      instructionType: SablierLockupInstruction.Withdraw;
    } & ParsedWithdrawInstruction<TProgram>)
  | ({
      instructionType: SablierLockupInstruction.WithdrawMax;
    } & ParsedWithdrawMaxInstruction<TProgram>)
  | ({
      instructionType: SablierLockupInstruction.WithdrawableAmountOf;
    } & ParsedWithdrawableAmountOfInstruction<TProgram>)
  | ({
      instructionType: SablierLockupInstruction.WithdrawalFeeInLamports;
    } & ParsedWithdrawalFeeInLamportsInstruction<TProgram>);
