/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getProgramDerivedAddress,
  getStructDecoder,
  getStructEncoder,
  transformEncoder,
  type AccountMeta,
  type AccountSignerMeta,
  type Address,
  type FixedSizeCodec,
  type FixedSizeDecoder,
  type FixedSizeEncoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type ReadonlyAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
  type WritableSignerAccount,
} from '@solana/kit';
import { SABLIER_LOCKUP_PROGRAM_ADDRESS } from '../programs';
import {
  expectAddress,
  getAccountMetaFactory,
  type ResolvedAccount,
} from '../shared';

export const INITIALIZE_DISCRIMINATOR = new Uint8Array([
  175, 175, 109, 31, 13, 152, 155, 237,
]);

export function getInitializeDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(INITIALIZE_DISCRIMINATOR);
}

export type InitializeInstruction<
  TProgram extends string = typeof SABLIER_LOCKUP_PROGRAM_ADDRESS,
  TAccountInitializer extends string | AccountMeta<string> = string,
  TAccountTreasury extends string | AccountMeta<string> = string,
  TAccountNftCollectionData extends string | AccountMeta<string> = string,
  TAccountNftCollectionMasterEdition extends
    | string
    | AccountMeta<string> = string,
  TAccountNftCollectionMetadata extends string | AccountMeta<string> = string,
  TAccountNftCollectionMint extends string | AccountMeta<string> = string,
  TAccountNftCollectionAta extends string | AccountMeta<string> = string,
  TAccountAssociatedTokenProgram extends
    | string
    | AccountMeta<string> = 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL',
  TAccountNftTokenProgram extends string | AccountMeta<string> = string,
  TAccountTokenMetadataProgram extends
    | string
    | AccountMeta<string> = 'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s',
  TAccountRent extends
    | string
    | AccountMeta<string> = 'SysvarRent111111111111111111111111111111111',
  TAccountSystemProgram extends
    | string
    | AccountMeta<string> = '11111111111111111111111111111111',
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountInitializer extends string
        ? WritableSignerAccount<TAccountInitializer> &
            AccountSignerMeta<TAccountInitializer>
        : TAccountInitializer,
      TAccountTreasury extends string
        ? WritableAccount<TAccountTreasury>
        : TAccountTreasury,
      TAccountNftCollectionData extends string
        ? WritableAccount<TAccountNftCollectionData>
        : TAccountNftCollectionData,
      TAccountNftCollectionMasterEdition extends string
        ? WritableAccount<TAccountNftCollectionMasterEdition>
        : TAccountNftCollectionMasterEdition,
      TAccountNftCollectionMetadata extends string
        ? WritableAccount<TAccountNftCollectionMetadata>
        : TAccountNftCollectionMetadata,
      TAccountNftCollectionMint extends string
        ? WritableAccount<TAccountNftCollectionMint>
        : TAccountNftCollectionMint,
      TAccountNftCollectionAta extends string
        ? WritableAccount<TAccountNftCollectionAta>
        : TAccountNftCollectionAta,
      TAccountAssociatedTokenProgram extends string
        ? ReadonlyAccount<TAccountAssociatedTokenProgram>
        : TAccountAssociatedTokenProgram,
      TAccountNftTokenProgram extends string
        ? ReadonlyAccount<TAccountNftTokenProgram>
        : TAccountNftTokenProgram,
      TAccountTokenMetadataProgram extends string
        ? ReadonlyAccount<TAccountTokenMetadataProgram>
        : TAccountTokenMetadataProgram,
      TAccountRent extends string
        ? ReadonlyAccount<TAccountRent>
        : TAccountRent,
      TAccountSystemProgram extends string
        ? ReadonlyAccount<TAccountSystemProgram>
        : TAccountSystemProgram,
      ...TRemainingAccounts,
    ]
  >;

export type InitializeInstructionData = {
  discriminator: ReadonlyUint8Array;
  feeCollector: Address;
  chainlinkProgram: Address;
  chainlinkSolUsdFeed: Address;
};

export type InitializeInstructionDataArgs = {
  feeCollector: Address;
  chainlinkProgram: Address;
  chainlinkSolUsdFeed: Address;
};

export function getInitializeInstructionDataEncoder(): FixedSizeEncoder<InitializeInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['feeCollector', getAddressEncoder()],
      ['chainlinkProgram', getAddressEncoder()],
      ['chainlinkSolUsdFeed', getAddressEncoder()],
    ]),
    (value) => ({ ...value, discriminator: INITIALIZE_DISCRIMINATOR })
  );
}

export function getInitializeInstructionDataDecoder(): FixedSizeDecoder<InitializeInstructionData> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['feeCollector', getAddressDecoder()],
    ['chainlinkProgram', getAddressDecoder()],
    ['chainlinkSolUsdFeed', getAddressDecoder()],
  ]);
}

export function getInitializeInstructionDataCodec(): FixedSizeCodec<
  InitializeInstructionDataArgs,
  InitializeInstructionData
> {
  return combineCodec(
    getInitializeInstructionDataEncoder(),
    getInitializeInstructionDataDecoder()
  );
}

export type InitializeAsyncInput<
  TAccountInitializer extends string = string,
  TAccountTreasury extends string = string,
  TAccountNftCollectionData extends string = string,
  TAccountNftCollectionMasterEdition extends string = string,
  TAccountNftCollectionMetadata extends string = string,
  TAccountNftCollectionMint extends string = string,
  TAccountNftCollectionAta extends string = string,
  TAccountAssociatedTokenProgram extends string = string,
  TAccountNftTokenProgram extends string = string,
  TAccountTokenMetadataProgram extends string = string,
  TAccountRent extends string = string,
  TAccountSystemProgram extends string = string,
> = {
  /** Write account: the initializer of the program. */
  initializer: TransactionSigner<TAccountInitializer>;
  /** Create account: the treasury account that will hold the fees. */
  treasury?: Address<TAccountTreasury>;
  /** Create account: the NFT collection data account storing collection metadata. */
  nftCollectionData?: Address<TAccountNftCollectionData>;
  /** Create account: the master edition account for the NFT collection. */
  nftCollectionMasterEdition?: Address<TAccountNftCollectionMasterEdition>;
  /** Create account: the metadata account for the NFT collection. */
  nftCollectionMetadata?: Address<TAccountNftCollectionMetadata>;
  /** Create account: the mint account for the NFT collection. */
  nftCollectionMint?: Address<TAccountNftCollectionMint>;
  /** Create account: the ATA for the NFT collection owned by treasury. */
  nftCollectionAta?: Address<TAccountNftCollectionAta>;
  /** Program account: the Associated Token program. */
  associatedTokenProgram?: Address<TAccountAssociatedTokenProgram>;
  /** Program account: the Token program of the collection NFT. */
  nftTokenProgram: Address<TAccountNftTokenProgram>;
  /** Program account: the Token Metadata program. */
  tokenMetadataProgram?: Address<TAccountTokenMetadataProgram>;
  /** Sysvar account: Rent. */
  rent?: Address<TAccountRent>;
  /** Program account: the System program. */
  systemProgram?: Address<TAccountSystemProgram>;
  feeCollector: InitializeInstructionDataArgs['feeCollector'];
  chainlinkProgram: InitializeInstructionDataArgs['chainlinkProgram'];
  chainlinkSolUsdFeed: InitializeInstructionDataArgs['chainlinkSolUsdFeed'];
};

export async function getInitializeInstructionAsync<
  TAccountInitializer extends string,
  TAccountTreasury extends string,
  TAccountNftCollectionData extends string,
  TAccountNftCollectionMasterEdition extends string,
  TAccountNftCollectionMetadata extends string,
  TAccountNftCollectionMint extends string,
  TAccountNftCollectionAta extends string,
  TAccountAssociatedTokenProgram extends string,
  TAccountNftTokenProgram extends string,
  TAccountTokenMetadataProgram extends string,
  TAccountRent extends string,
  TAccountSystemProgram extends string,
  TProgramAddress extends Address = typeof SABLIER_LOCKUP_PROGRAM_ADDRESS,
>(
  input: InitializeAsyncInput<
    TAccountInitializer,
    TAccountTreasury,
    TAccountNftCollectionData,
    TAccountNftCollectionMasterEdition,
    TAccountNftCollectionMetadata,
    TAccountNftCollectionMint,
    TAccountNftCollectionAta,
    TAccountAssociatedTokenProgram,
    TAccountNftTokenProgram,
    TAccountTokenMetadataProgram,
    TAccountRent,
    TAccountSystemProgram
  >,
  config?: { programAddress?: TProgramAddress }
): Promise<
  InitializeInstruction<
    TProgramAddress,
    TAccountInitializer,
    TAccountTreasury,
    TAccountNftCollectionData,
    TAccountNftCollectionMasterEdition,
    TAccountNftCollectionMetadata,
    TAccountNftCollectionMint,
    TAccountNftCollectionAta,
    TAccountAssociatedTokenProgram,
    TAccountNftTokenProgram,
    TAccountTokenMetadataProgram,
    TAccountRent,
    TAccountSystemProgram
  >
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? SABLIER_LOCKUP_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    initializer: { value: input.initializer ?? null, isWritable: true },
    treasury: { value: input.treasury ?? null, isWritable: true },
    nftCollectionData: {
      value: input.nftCollectionData ?? null,
      isWritable: true,
    },
    nftCollectionMasterEdition: {
      value: input.nftCollectionMasterEdition ?? null,
      isWritable: true,
    },
    nftCollectionMetadata: {
      value: input.nftCollectionMetadata ?? null,
      isWritable: true,
    },
    nftCollectionMint: {
      value: input.nftCollectionMint ?? null,
      isWritable: true,
    },
    nftCollectionAta: {
      value: input.nftCollectionAta ?? null,
      isWritable: true,
    },
    associatedTokenProgram: {
      value: input.associatedTokenProgram ?? null,
      isWritable: false,
    },
    nftTokenProgram: {
      value: input.nftTokenProgram ?? null,
      isWritable: false,
    },
    tokenMetadataProgram: {
      value: input.tokenMetadataProgram ?? null,
      isWritable: false,
    },
    rent: { value: input.rent ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.treasury.value) {
    accounts.treasury.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([116, 114, 101, 97, 115, 117, 114, 121])
        ),
      ],
    });
  }
  if (!accounts.nftCollectionData.value) {
    accounts.nftCollectionData.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([
            110, 102, 116, 95, 99, 111, 108, 108, 101, 99, 116, 105, 111, 110,
            95, 100, 97, 116, 97,
          ])
        ),
      ],
    });
  }
  if (!accounts.tokenMetadataProgram.value) {
    accounts.tokenMetadataProgram.value =
      'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s' as Address<'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s'>;
  }
  if (!accounts.nftCollectionMint.value) {
    accounts.nftCollectionMint.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([
            110, 102, 116, 95, 99, 111, 108, 108, 101, 99, 116, 105, 111, 110,
            95, 109, 105, 110, 116,
          ])
        ),
      ],
    });
  }
  if (!accounts.nftCollectionMasterEdition.value) {
    accounts.nftCollectionMasterEdition.value = await getProgramDerivedAddress({
      programAddress:
        'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s' as Address<'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s'>,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([109, 101, 116, 97, 100, 97, 116, 97])
        ),
        getAddressEncoder().encode(
          expectAddress(accounts.tokenMetadataProgram.value)
        ),
        getAddressEncoder().encode(
          expectAddress(accounts.nftCollectionMint.value)
        ),
        getBytesEncoder().encode(
          new Uint8Array([101, 100, 105, 116, 105, 111, 110])
        ),
      ],
    });
  }
  if (!accounts.nftCollectionMetadata.value) {
    accounts.nftCollectionMetadata.value = await getProgramDerivedAddress({
      programAddress:
        'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s' as Address<'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s'>,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([109, 101, 116, 97, 100, 97, 116, 97])
        ),
        getAddressEncoder().encode(
          expectAddress(accounts.tokenMetadataProgram.value)
        ),
        getAddressEncoder().encode(
          expectAddress(accounts.nftCollectionMint.value)
        ),
      ],
    });
  }
  if (!accounts.nftCollectionAta.value) {
    accounts.nftCollectionAta.value = await getProgramDerivedAddress({
      programAddress:
        'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address<'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'>,
      seeds: [
        getAddressEncoder().encode(expectAddress(accounts.treasury.value)),
        getAddressEncoder().encode(
          expectAddress(accounts.nftTokenProgram.value)
        ),
        getAddressEncoder().encode(
          expectAddress(accounts.nftCollectionMint.value)
        ),
      ],
    });
  }
  if (!accounts.associatedTokenProgram.value) {
    accounts.associatedTokenProgram.value =
      'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address<'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'>;
  }
  if (!accounts.rent.value) {
    accounts.rent.value =
      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.initializer),
      getAccountMeta(accounts.treasury),
      getAccountMeta(accounts.nftCollectionData),
      getAccountMeta(accounts.nftCollectionMasterEdition),
      getAccountMeta(accounts.nftCollectionMetadata),
      getAccountMeta(accounts.nftCollectionMint),
      getAccountMeta(accounts.nftCollectionAta),
      getAccountMeta(accounts.associatedTokenProgram),
      getAccountMeta(accounts.nftTokenProgram),
      getAccountMeta(accounts.tokenMetadataProgram),
      getAccountMeta(accounts.rent),
      getAccountMeta(accounts.systemProgram),
    ],
    data: getInitializeInstructionDataEncoder().encode(
      args as InitializeInstructionDataArgs
    ),
    programAddress,
  } as InitializeInstruction<
    TProgramAddress,
    TAccountInitializer,
    TAccountTreasury,
    TAccountNftCollectionData,
    TAccountNftCollectionMasterEdition,
    TAccountNftCollectionMetadata,
    TAccountNftCollectionMint,
    TAccountNftCollectionAta,
    TAccountAssociatedTokenProgram,
    TAccountNftTokenProgram,
    TAccountTokenMetadataProgram,
    TAccountRent,
    TAccountSystemProgram
  >);
}

export type InitializeInput<
  TAccountInitializer extends string = string,
  TAccountTreasury extends string = string,
  TAccountNftCollectionData extends string = string,
  TAccountNftCollectionMasterEdition extends string = string,
  TAccountNftCollectionMetadata extends string = string,
  TAccountNftCollectionMint extends string = string,
  TAccountNftCollectionAta extends string = string,
  TAccountAssociatedTokenProgram extends string = string,
  TAccountNftTokenProgram extends string = string,
  TAccountTokenMetadataProgram extends string = string,
  TAccountRent extends string = string,
  TAccountSystemProgram extends string = string,
> = {
  /** Write account: the initializer of the program. */
  initializer: TransactionSigner<TAccountInitializer>;
  /** Create account: the treasury account that will hold the fees. */
  treasury: Address<TAccountTreasury>;
  /** Create account: the NFT collection data account storing collection metadata. */
  nftCollectionData: Address<TAccountNftCollectionData>;
  /** Create account: the master edition account for the NFT collection. */
  nftCollectionMasterEdition: Address<TAccountNftCollectionMasterEdition>;
  /** Create account: the metadata account for the NFT collection. */
  nftCollectionMetadata: Address<TAccountNftCollectionMetadata>;
  /** Create account: the mint account for the NFT collection. */
  nftCollectionMint: Address<TAccountNftCollectionMint>;
  /** Create account: the ATA for the NFT collection owned by treasury. */
  nftCollectionAta: Address<TAccountNftCollectionAta>;
  /** Program account: the Associated Token program. */
  associatedTokenProgram?: Address<TAccountAssociatedTokenProgram>;
  /** Program account: the Token program of the collection NFT. */
  nftTokenProgram: Address<TAccountNftTokenProgram>;
  /** Program account: the Token Metadata program. */
  tokenMetadataProgram?: Address<TAccountTokenMetadataProgram>;
  /** Sysvar account: Rent. */
  rent?: Address<TAccountRent>;
  /** Program account: the System program. */
  systemProgram?: Address<TAccountSystemProgram>;
  feeCollector: InitializeInstructionDataArgs['feeCollector'];
  chainlinkProgram: InitializeInstructionDataArgs['chainlinkProgram'];
  chainlinkSolUsdFeed: InitializeInstructionDataArgs['chainlinkSolUsdFeed'];
};

export function getInitializeInstruction<
  TAccountInitializer extends string,
  TAccountTreasury extends string,
  TAccountNftCollectionData extends string,
  TAccountNftCollectionMasterEdition extends string,
  TAccountNftCollectionMetadata extends string,
  TAccountNftCollectionMint extends string,
  TAccountNftCollectionAta extends string,
  TAccountAssociatedTokenProgram extends string,
  TAccountNftTokenProgram extends string,
  TAccountTokenMetadataProgram extends string,
  TAccountRent extends string,
  TAccountSystemProgram extends string,
  TProgramAddress extends Address = typeof SABLIER_LOCKUP_PROGRAM_ADDRESS,
>(
  input: InitializeInput<
    TAccountInitializer,
    TAccountTreasury,
    TAccountNftCollectionData,
    TAccountNftCollectionMasterEdition,
    TAccountNftCollectionMetadata,
    TAccountNftCollectionMint,
    TAccountNftCollectionAta,
    TAccountAssociatedTokenProgram,
    TAccountNftTokenProgram,
    TAccountTokenMetadataProgram,
    TAccountRent,
    TAccountSystemProgram
  >,
  config?: { programAddress?: TProgramAddress }
): InitializeInstruction<
  TProgramAddress,
  TAccountInitializer,
  TAccountTreasury,
  TAccountNftCollectionData,
  TAccountNftCollectionMasterEdition,
  TAccountNftCollectionMetadata,
  TAccountNftCollectionMint,
  TAccountNftCollectionAta,
  TAccountAssociatedTokenProgram,
  TAccountNftTokenProgram,
  TAccountTokenMetadataProgram,
  TAccountRent,
  TAccountSystemProgram
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? SABLIER_LOCKUP_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    initializer: { value: input.initializer ?? null, isWritable: true },
    treasury: { value: input.treasury ?? null, isWritable: true },
    nftCollectionData: {
      value: input.nftCollectionData ?? null,
      isWritable: true,
    },
    nftCollectionMasterEdition: {
      value: input.nftCollectionMasterEdition ?? null,
      isWritable: true,
    },
    nftCollectionMetadata: {
      value: input.nftCollectionMetadata ?? null,
      isWritable: true,
    },
    nftCollectionMint: {
      value: input.nftCollectionMint ?? null,
      isWritable: true,
    },
    nftCollectionAta: {
      value: input.nftCollectionAta ?? null,
      isWritable: true,
    },
    associatedTokenProgram: {
      value: input.associatedTokenProgram ?? null,
      isWritable: false,
    },
    nftTokenProgram: {
      value: input.nftTokenProgram ?? null,
      isWritable: false,
    },
    tokenMetadataProgram: {
      value: input.tokenMetadataProgram ?? null,
      isWritable: false,
    },
    rent: { value: input.rent ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.tokenMetadataProgram.value) {
    accounts.tokenMetadataProgram.value =
      'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s' as Address<'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s'>;
  }
  if (!accounts.associatedTokenProgram.value) {
    accounts.associatedTokenProgram.value =
      'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address<'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'>;
  }
  if (!accounts.rent.value) {
    accounts.rent.value =
      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.initializer),
      getAccountMeta(accounts.treasury),
      getAccountMeta(accounts.nftCollectionData),
      getAccountMeta(accounts.nftCollectionMasterEdition),
      getAccountMeta(accounts.nftCollectionMetadata),
      getAccountMeta(accounts.nftCollectionMint),
      getAccountMeta(accounts.nftCollectionAta),
      getAccountMeta(accounts.associatedTokenProgram),
      getAccountMeta(accounts.nftTokenProgram),
      getAccountMeta(accounts.tokenMetadataProgram),
      getAccountMeta(accounts.rent),
      getAccountMeta(accounts.systemProgram),
    ],
    data: getInitializeInstructionDataEncoder().encode(
      args as InitializeInstructionDataArgs
    ),
    programAddress,
  } as InitializeInstruction<
    TProgramAddress,
    TAccountInitializer,
    TAccountTreasury,
    TAccountNftCollectionData,
    TAccountNftCollectionMasterEdition,
    TAccountNftCollectionMetadata,
    TAccountNftCollectionMint,
    TAccountNftCollectionAta,
    TAccountAssociatedTokenProgram,
    TAccountNftTokenProgram,
    TAccountTokenMetadataProgram,
    TAccountRent,
    TAccountSystemProgram
  >);
}

export type ParsedInitializeInstruction<
  TProgram extends string = typeof SABLIER_LOCKUP_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    /** Write account: the initializer of the program. */
    initializer: TAccountMetas[0];
    /** Create account: the treasury account that will hold the fees. */
    treasury: TAccountMetas[1];
    /** Create account: the NFT collection data account storing collection metadata. */
    nftCollectionData: TAccountMetas[2];
    /** Create account: the master edition account for the NFT collection. */
    nftCollectionMasterEdition: TAccountMetas[3];
    /** Create account: the metadata account for the NFT collection. */
    nftCollectionMetadata: TAccountMetas[4];
    /** Create account: the mint account for the NFT collection. */
    nftCollectionMint: TAccountMetas[5];
    /** Create account: the ATA for the NFT collection owned by treasury. */
    nftCollectionAta: TAccountMetas[6];
    /** Program account: the Associated Token program. */
    associatedTokenProgram: TAccountMetas[7];
    /** Program account: the Token program of the collection NFT. */
    nftTokenProgram: TAccountMetas[8];
    /** Program account: the Token Metadata program. */
    tokenMetadataProgram: TAccountMetas[9];
    /** Sysvar account: Rent. */
    rent: TAccountMetas[10];
    /** Program account: the System program. */
    systemProgram: TAccountMetas[11];
  };
  data: InitializeInstructionData;
};

export function parseInitializeInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>
): ParsedInitializeInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 12) {
    // TODO: Coded error.
    throw new Error('Not enough accounts');
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      initializer: getNextAccount(),
      treasury: getNextAccount(),
      nftCollectionData: getNextAccount(),
      nftCollectionMasterEdition: getNextAccount(),
      nftCollectionMetadata: getNextAccount(),
      nftCollectionMint: getNextAccount(),
      nftCollectionAta: getNextAccount(),
      associatedTokenProgram: getNextAccount(),
      nftTokenProgram: getNextAccount(),
      tokenMetadataProgram: getNextAccount(),
      rent: getNextAccount(),
      systemProgram: getNextAccount(),
    },
    data: getInitializeInstructionDataDecoder().decode(instruction.data),
  };
}
