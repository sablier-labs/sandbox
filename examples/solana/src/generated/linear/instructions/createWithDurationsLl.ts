/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getAddressEncoder,
  getBooleanDecoder,
  getBooleanEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getProgramDerivedAddress,
  getStructDecoder,
  getStructEncoder,
  getU128Decoder,
  getU128Encoder,
  getU64Decoder,
  getU64Encoder,
  transformEncoder,
  type AccountMeta,
  type AccountSignerMeta,
  type Address,
  type FixedSizeCodec,
  type FixedSizeDecoder,
  type FixedSizeEncoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type ReadonlyAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
  type WritableSignerAccount,
} from '@solana/kit';
import { SABLIER_LOCKUP_PROGRAM_ADDRESS } from '../programs';
import {
  expectAddress,
  expectSome,
  getAccountMetaFactory,
  type ResolvedAccount,
} from '../shared';

export const CREATE_WITH_DURATIONS_LL_DISCRIMINATOR = new Uint8Array([
  87, 17, 170, 167, 156, 152, 169, 61,
]);

export function getCreateWithDurationsLlDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    CREATE_WITH_DURATIONS_LL_DISCRIMINATOR
  );
}

export type CreateWithDurationsLlInstruction<
  TProgram extends string = typeof SABLIER_LOCKUP_PROGRAM_ADDRESS,
  TAccountCreator extends string | AccountMeta<string> = string,
  TAccountCreatorAta extends string | AccountMeta<string> = string,
  TAccountRecipient extends string | AccountMeta<string> = string,
  TAccountSender extends string | AccountMeta<string> = string,
  TAccountNftCollectionData extends string | AccountMeta<string> = string,
  TAccountNftCollectionMasterEdition extends
    | string
    | AccountMeta<string> = string,
  TAccountNftCollectionMetadata extends string | AccountMeta<string> = string,
  TAccountNftCollectionMint extends string | AccountMeta<string> = string,
  TAccountDepositTokenMint extends string | AccountMeta<string> = string,
  TAccountStreamNftMint extends string | AccountMeta<string> = string,
  TAccountRecipientStreamNftAta extends string | AccountMeta<string> = string,
  TAccountStreamData extends string | AccountMeta<string> = string,
  TAccountStreamDataAta extends string | AccountMeta<string> = string,
  TAccountStreamNftMasterEdition extends string | AccountMeta<string> = string,
  TAccountStreamNftMetadata extends string | AccountMeta<string> = string,
  TAccountAssociatedTokenProgram extends
    | string
    | AccountMeta<string> = 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL',
  TAccountDepositTokenProgram extends string | AccountMeta<string> = string,
  TAccountNftTokenProgram extends string | AccountMeta<string> = string,
  TAccountTokenMetadataProgram extends
    | string
    | AccountMeta<string> = 'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s',
  TAccountSystemProgram extends
    | string
    | AccountMeta<string> = '11111111111111111111111111111111',
  TAccountRent extends
    | string
    | AccountMeta<string> = 'SysvarRent111111111111111111111111111111111',
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountCreator extends string
        ? WritableSignerAccount<TAccountCreator> &
            AccountSignerMeta<TAccountCreator>
        : TAccountCreator,
      TAccountCreatorAta extends string
        ? WritableAccount<TAccountCreatorAta>
        : TAccountCreatorAta,
      TAccountRecipient extends string
        ? ReadonlyAccount<TAccountRecipient>
        : TAccountRecipient,
      TAccountSender extends string
        ? ReadonlyAccount<TAccountSender>
        : TAccountSender,
      TAccountNftCollectionData extends string
        ? WritableAccount<TAccountNftCollectionData>
        : TAccountNftCollectionData,
      TAccountNftCollectionMasterEdition extends string
        ? ReadonlyAccount<TAccountNftCollectionMasterEdition>
        : TAccountNftCollectionMasterEdition,
      TAccountNftCollectionMetadata extends string
        ? WritableAccount<TAccountNftCollectionMetadata>
        : TAccountNftCollectionMetadata,
      TAccountNftCollectionMint extends string
        ? ReadonlyAccount<TAccountNftCollectionMint>
        : TAccountNftCollectionMint,
      TAccountDepositTokenMint extends string
        ? ReadonlyAccount<TAccountDepositTokenMint>
        : TAccountDepositTokenMint,
      TAccountStreamNftMint extends string
        ? WritableAccount<TAccountStreamNftMint>
        : TAccountStreamNftMint,
      TAccountRecipientStreamNftAta extends string
        ? WritableAccount<TAccountRecipientStreamNftAta>
        : TAccountRecipientStreamNftAta,
      TAccountStreamData extends string
        ? WritableAccount<TAccountStreamData>
        : TAccountStreamData,
      TAccountStreamDataAta extends string
        ? WritableAccount<TAccountStreamDataAta>
        : TAccountStreamDataAta,
      TAccountStreamNftMasterEdition extends string
        ? WritableAccount<TAccountStreamNftMasterEdition>
        : TAccountStreamNftMasterEdition,
      TAccountStreamNftMetadata extends string
        ? WritableAccount<TAccountStreamNftMetadata>
        : TAccountStreamNftMetadata,
      TAccountAssociatedTokenProgram extends string
        ? ReadonlyAccount<TAccountAssociatedTokenProgram>
        : TAccountAssociatedTokenProgram,
      TAccountDepositTokenProgram extends string
        ? ReadonlyAccount<TAccountDepositTokenProgram>
        : TAccountDepositTokenProgram,
      TAccountNftTokenProgram extends string
        ? ReadonlyAccount<TAccountNftTokenProgram>
        : TAccountNftTokenProgram,
      TAccountTokenMetadataProgram extends string
        ? ReadonlyAccount<TAccountTokenMetadataProgram>
        : TAccountTokenMetadataProgram,
      TAccountSystemProgram extends string
        ? ReadonlyAccount<TAccountSystemProgram>
        : TAccountSystemProgram,
      TAccountRent extends string
        ? ReadonlyAccount<TAccountRent>
        : TAccountRent,
      ...TRemainingAccounts,
    ]
  >;

export type CreateWithDurationsLlInstructionData = {
  discriminator: ReadonlyUint8Array;
  salt: bigint;
  depositAmount: bigint;
  cliffDuration: bigint;
  totalDuration: bigint;
  startUnlockAmount: bigint;
  cliffUnlockAmount: bigint;
  isCancelable: boolean;
};

export type CreateWithDurationsLlInstructionDataArgs = {
  salt: number | bigint;
  depositAmount: number | bigint;
  cliffDuration: number | bigint;
  totalDuration: number | bigint;
  startUnlockAmount: number | bigint;
  cliffUnlockAmount: number | bigint;
  isCancelable: boolean;
};

export function getCreateWithDurationsLlInstructionDataEncoder(): FixedSizeEncoder<CreateWithDurationsLlInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['salt', getU128Encoder()],
      ['depositAmount', getU64Encoder()],
      ['cliffDuration', getU64Encoder()],
      ['totalDuration', getU64Encoder()],
      ['startUnlockAmount', getU64Encoder()],
      ['cliffUnlockAmount', getU64Encoder()],
      ['isCancelable', getBooleanEncoder()],
    ]),
    (value) => ({
      ...value,
      discriminator: CREATE_WITH_DURATIONS_LL_DISCRIMINATOR,
    })
  );
}

export function getCreateWithDurationsLlInstructionDataDecoder(): FixedSizeDecoder<CreateWithDurationsLlInstructionData> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['salt', getU128Decoder()],
    ['depositAmount', getU64Decoder()],
    ['cliffDuration', getU64Decoder()],
    ['totalDuration', getU64Decoder()],
    ['startUnlockAmount', getU64Decoder()],
    ['cliffUnlockAmount', getU64Decoder()],
    ['isCancelable', getBooleanDecoder()],
  ]);
}

export function getCreateWithDurationsLlInstructionDataCodec(): FixedSizeCodec<
  CreateWithDurationsLlInstructionDataArgs,
  CreateWithDurationsLlInstructionData
> {
  return combineCodec(
    getCreateWithDurationsLlInstructionDataEncoder(),
    getCreateWithDurationsLlInstructionDataDecoder()
  );
}

export type CreateWithDurationsLlAsyncInput<
  TAccountCreator extends string = string,
  TAccountCreatorAta extends string = string,
  TAccountRecipient extends string = string,
  TAccountSender extends string = string,
  TAccountNftCollectionData extends string = string,
  TAccountNftCollectionMasterEdition extends string = string,
  TAccountNftCollectionMetadata extends string = string,
  TAccountNftCollectionMint extends string = string,
  TAccountDepositTokenMint extends string = string,
  TAccountStreamNftMint extends string = string,
  TAccountRecipientStreamNftAta extends string = string,
  TAccountStreamData extends string = string,
  TAccountStreamDataAta extends string = string,
  TAccountStreamNftMasterEdition extends string = string,
  TAccountStreamNftMetadata extends string = string,
  TAccountAssociatedTokenProgram extends string = string,
  TAccountDepositTokenProgram extends string = string,
  TAccountNftTokenProgram extends string = string,
  TAccountTokenMetadataProgram extends string = string,
  TAccountSystemProgram extends string = string,
  TAccountRent extends string = string,
> = {
  /** Write account: the creator and funder of the stream. */
  creator: TransactionSigner<TAccountCreator>;
  /** Write account: the creator's ATA for the deposit token. */
  creatorAta?: Address<TAccountCreatorAta>;
  /** Read account: the recipient of the stream. */
  recipient: Address<TAccountRecipient>;
  /** Read account: the sender of the stream. */
  sender: Address<TAccountSender>;
  /** Write account: the NFT collection data storing the total supply. */
  nftCollectionData?: Address<TAccountNftCollectionData>;
  /** Write account: the master edition account for the NFT collection. */
  nftCollectionMasterEdition?: Address<TAccountNftCollectionMasterEdition>;
  /** Write account: the metadata account for the NFT collection. */
  nftCollectionMetadata?: Address<TAccountNftCollectionMetadata>;
  /** Read account: the mint account for the NFT collection. */
  nftCollectionMint?: Address<TAccountNftCollectionMint>;
  /** Read account: the mint account for the deposit token. */
  depositTokenMint: Address<TAccountDepositTokenMint>;
  /** Create account: the mint account for the stream NFT. */
  streamNftMint?: Address<TAccountStreamNftMint>;
  /** Create account: the ATA for the stream NFT owned by the recipient. */
  recipientStreamNftAta?: Address<TAccountRecipientStreamNftAta>;
  /** Create account: the account that will store the stream data. */
  streamData?: Address<TAccountStreamData>;
  /** Create account: the ATA for deposit tokens owned by stream data account. */
  streamDataAta?: Address<TAccountStreamDataAta>;
  /** Create account: the master edition account for the stream NFT. */
  streamNftMasterEdition?: Address<TAccountStreamNftMasterEdition>;
  /** Create account: the metadata account for the stream NFT. */
  streamNftMetadata?: Address<TAccountStreamNftMetadata>;
  /** Program account: the Associated Token program. */
  associatedTokenProgram?: Address<TAccountAssociatedTokenProgram>;
  /** Program account: the Token program of the deposit token. */
  depositTokenProgram: Address<TAccountDepositTokenProgram>;
  /** Program account: the Token program of the stream NFT. */
  nftTokenProgram: Address<TAccountNftTokenProgram>;
  /** Program account: the Token Metadata program. */
  tokenMetadataProgram?: Address<TAccountTokenMetadataProgram>;
  /** Program account: the System program. */
  systemProgram?: Address<TAccountSystemProgram>;
  /** Sysvar account: Rent. */
  rent?: Address<TAccountRent>;
  salt: CreateWithDurationsLlInstructionDataArgs['salt'];
  depositAmount: CreateWithDurationsLlInstructionDataArgs['depositAmount'];
  cliffDuration: CreateWithDurationsLlInstructionDataArgs['cliffDuration'];
  totalDuration: CreateWithDurationsLlInstructionDataArgs['totalDuration'];
  startUnlockAmount: CreateWithDurationsLlInstructionDataArgs['startUnlockAmount'];
  cliffUnlockAmount: CreateWithDurationsLlInstructionDataArgs['cliffUnlockAmount'];
  isCancelable: CreateWithDurationsLlInstructionDataArgs['isCancelable'];
};

export async function getCreateWithDurationsLlInstructionAsync<
  TAccountCreator extends string,
  TAccountCreatorAta extends string,
  TAccountRecipient extends string,
  TAccountSender extends string,
  TAccountNftCollectionData extends string,
  TAccountNftCollectionMasterEdition extends string,
  TAccountNftCollectionMetadata extends string,
  TAccountNftCollectionMint extends string,
  TAccountDepositTokenMint extends string,
  TAccountStreamNftMint extends string,
  TAccountRecipientStreamNftAta extends string,
  TAccountStreamData extends string,
  TAccountStreamDataAta extends string,
  TAccountStreamNftMasterEdition extends string,
  TAccountStreamNftMetadata extends string,
  TAccountAssociatedTokenProgram extends string,
  TAccountDepositTokenProgram extends string,
  TAccountNftTokenProgram extends string,
  TAccountTokenMetadataProgram extends string,
  TAccountSystemProgram extends string,
  TAccountRent extends string,
  TProgramAddress extends Address = typeof SABLIER_LOCKUP_PROGRAM_ADDRESS,
>(
  input: CreateWithDurationsLlAsyncInput<
    TAccountCreator,
    TAccountCreatorAta,
    TAccountRecipient,
    TAccountSender,
    TAccountNftCollectionData,
    TAccountNftCollectionMasterEdition,
    TAccountNftCollectionMetadata,
    TAccountNftCollectionMint,
    TAccountDepositTokenMint,
    TAccountStreamNftMint,
    TAccountRecipientStreamNftAta,
    TAccountStreamData,
    TAccountStreamDataAta,
    TAccountStreamNftMasterEdition,
    TAccountStreamNftMetadata,
    TAccountAssociatedTokenProgram,
    TAccountDepositTokenProgram,
    TAccountNftTokenProgram,
    TAccountTokenMetadataProgram,
    TAccountSystemProgram,
    TAccountRent
  >,
  config?: { programAddress?: TProgramAddress }
): Promise<
  CreateWithDurationsLlInstruction<
    TProgramAddress,
    TAccountCreator,
    TAccountCreatorAta,
    TAccountRecipient,
    TAccountSender,
    TAccountNftCollectionData,
    TAccountNftCollectionMasterEdition,
    TAccountNftCollectionMetadata,
    TAccountNftCollectionMint,
    TAccountDepositTokenMint,
    TAccountStreamNftMint,
    TAccountRecipientStreamNftAta,
    TAccountStreamData,
    TAccountStreamDataAta,
    TAccountStreamNftMasterEdition,
    TAccountStreamNftMetadata,
    TAccountAssociatedTokenProgram,
    TAccountDepositTokenProgram,
    TAccountNftTokenProgram,
    TAccountTokenMetadataProgram,
    TAccountSystemProgram,
    TAccountRent
  >
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? SABLIER_LOCKUP_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    creator: { value: input.creator ?? null, isWritable: true },
    creatorAta: { value: input.creatorAta ?? null, isWritable: true },
    recipient: { value: input.recipient ?? null, isWritable: false },
    sender: { value: input.sender ?? null, isWritable: false },
    nftCollectionData: {
      value: input.nftCollectionData ?? null,
      isWritable: true,
    },
    nftCollectionMasterEdition: {
      value: input.nftCollectionMasterEdition ?? null,
      isWritable: false,
    },
    nftCollectionMetadata: {
      value: input.nftCollectionMetadata ?? null,
      isWritable: true,
    },
    nftCollectionMint: {
      value: input.nftCollectionMint ?? null,
      isWritable: false,
    },
    depositTokenMint: {
      value: input.depositTokenMint ?? null,
      isWritable: false,
    },
    streamNftMint: { value: input.streamNftMint ?? null, isWritable: true },
    recipientStreamNftAta: {
      value: input.recipientStreamNftAta ?? null,
      isWritable: true,
    },
    streamData: { value: input.streamData ?? null, isWritable: true },
    streamDataAta: { value: input.streamDataAta ?? null, isWritable: true },
    streamNftMasterEdition: {
      value: input.streamNftMasterEdition ?? null,
      isWritable: true,
    },
    streamNftMetadata: {
      value: input.streamNftMetadata ?? null,
      isWritable: true,
    },
    associatedTokenProgram: {
      value: input.associatedTokenProgram ?? null,
      isWritable: false,
    },
    depositTokenProgram: {
      value: input.depositTokenProgram ?? null,
      isWritable: false,
    },
    nftTokenProgram: {
      value: input.nftTokenProgram ?? null,
      isWritable: false,
    },
    tokenMetadataProgram: {
      value: input.tokenMetadataProgram ?? null,
      isWritable: false,
    },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.creatorAta.value) {
    accounts.creatorAta.value = await getProgramDerivedAddress({
      programAddress:
        'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address<'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'>,
      seeds: [
        getAddressEncoder().encode(expectAddress(accounts.creator.value)),
        getAddressEncoder().encode(
          expectAddress(accounts.depositTokenProgram.value)
        ),
        getAddressEncoder().encode(
          expectAddress(accounts.depositTokenMint.value)
        ),
      ],
    });
  }
  if (!accounts.nftCollectionData.value) {
    accounts.nftCollectionData.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([
            110, 102, 116, 95, 99, 111, 108, 108, 101, 99, 116, 105, 111, 110,
            95, 100, 97, 116, 97,
          ])
        ),
      ],
    });
  }
  if (!accounts.tokenMetadataProgram.value) {
    accounts.tokenMetadataProgram.value =
      'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s' as Address<'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s'>;
  }
  if (!accounts.nftCollectionMint.value) {
    accounts.nftCollectionMint.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([
            110, 102, 116, 95, 99, 111, 108, 108, 101, 99, 116, 105, 111, 110,
            95, 109, 105, 110, 116,
          ])
        ),
      ],
    });
  }
  if (!accounts.nftCollectionMasterEdition.value) {
    accounts.nftCollectionMasterEdition.value = await getProgramDerivedAddress({
      programAddress:
        'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s' as Address<'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s'>,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([109, 101, 116, 97, 100, 97, 116, 97])
        ),
        getAddressEncoder().encode(
          expectAddress(accounts.tokenMetadataProgram.value)
        ),
        getAddressEncoder().encode(
          expectAddress(accounts.nftCollectionMint.value)
        ),
        getBytesEncoder().encode(
          new Uint8Array([101, 100, 105, 116, 105, 111, 110])
        ),
      ],
    });
  }
  if (!accounts.nftCollectionMetadata.value) {
    accounts.nftCollectionMetadata.value = await getProgramDerivedAddress({
      programAddress:
        'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s' as Address<'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s'>,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([109, 101, 116, 97, 100, 97, 116, 97])
        ),
        getAddressEncoder().encode(
          expectAddress(accounts.tokenMetadataProgram.value)
        ),
        getAddressEncoder().encode(
          expectAddress(accounts.nftCollectionMint.value)
        ),
      ],
    });
  }
  if (!accounts.streamNftMint.value) {
    accounts.streamNftMint.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([
            115, 116, 114, 101, 97, 109, 95, 110, 102, 116, 95, 109, 105, 110,
            116,
          ])
        ),
        getAddressEncoder().encode(expectAddress(accounts.sender.value)),
        getU128Encoder().encode(expectSome(args.salt)),
      ],
    });
  }
  if (!accounts.recipientStreamNftAta.value) {
    accounts.recipientStreamNftAta.value = await getProgramDerivedAddress({
      programAddress:
        'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address<'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'>,
      seeds: [
        getAddressEncoder().encode(expectAddress(accounts.recipient.value)),
        getAddressEncoder().encode(
          expectAddress(accounts.nftTokenProgram.value)
        ),
        getAddressEncoder().encode(expectAddress(accounts.streamNftMint.value)),
      ],
    });
  }
  if (!accounts.streamData.value) {
    accounts.streamData.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([115, 116, 114, 101, 97, 109, 95, 100, 97, 116, 97])
        ),
        getAddressEncoder().encode(expectAddress(accounts.streamNftMint.value)),
      ],
    });
  }
  if (!accounts.streamDataAta.value) {
    accounts.streamDataAta.value = await getProgramDerivedAddress({
      programAddress:
        'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address<'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'>,
      seeds: [
        getAddressEncoder().encode(expectAddress(accounts.streamData.value)),
        getAddressEncoder().encode(
          expectAddress(accounts.depositTokenProgram.value)
        ),
        getAddressEncoder().encode(
          expectAddress(accounts.depositTokenMint.value)
        ),
      ],
    });
  }
  if (!accounts.streamNftMasterEdition.value) {
    accounts.streamNftMasterEdition.value = await getProgramDerivedAddress({
      programAddress:
        'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s' as Address<'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s'>,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([109, 101, 116, 97, 100, 97, 116, 97])
        ),
        getAddressEncoder().encode(
          expectAddress(accounts.tokenMetadataProgram.value)
        ),
        getAddressEncoder().encode(expectAddress(accounts.streamNftMint.value)),
        getBytesEncoder().encode(
          new Uint8Array([101, 100, 105, 116, 105, 111, 110])
        ),
      ],
    });
  }
  if (!accounts.streamNftMetadata.value) {
    accounts.streamNftMetadata.value = await getProgramDerivedAddress({
      programAddress:
        'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s' as Address<'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s'>,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([109, 101, 116, 97, 100, 97, 116, 97])
        ),
        getAddressEncoder().encode(
          expectAddress(accounts.tokenMetadataProgram.value)
        ),
        getAddressEncoder().encode(expectAddress(accounts.streamNftMint.value)),
      ],
    });
  }
  if (!accounts.associatedTokenProgram.value) {
    accounts.associatedTokenProgram.value =
      'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address<'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'>;
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }
  if (!accounts.rent.value) {
    accounts.rent.value =
      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.creator),
      getAccountMeta(accounts.creatorAta),
      getAccountMeta(accounts.recipient),
      getAccountMeta(accounts.sender),
      getAccountMeta(accounts.nftCollectionData),
      getAccountMeta(accounts.nftCollectionMasterEdition),
      getAccountMeta(accounts.nftCollectionMetadata),
      getAccountMeta(accounts.nftCollectionMint),
      getAccountMeta(accounts.depositTokenMint),
      getAccountMeta(accounts.streamNftMint),
      getAccountMeta(accounts.recipientStreamNftAta),
      getAccountMeta(accounts.streamData),
      getAccountMeta(accounts.streamDataAta),
      getAccountMeta(accounts.streamNftMasterEdition),
      getAccountMeta(accounts.streamNftMetadata),
      getAccountMeta(accounts.associatedTokenProgram),
      getAccountMeta(accounts.depositTokenProgram),
      getAccountMeta(accounts.nftTokenProgram),
      getAccountMeta(accounts.tokenMetadataProgram),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent),
    ],
    data: getCreateWithDurationsLlInstructionDataEncoder().encode(
      args as CreateWithDurationsLlInstructionDataArgs
    ),
    programAddress,
  } as CreateWithDurationsLlInstruction<
    TProgramAddress,
    TAccountCreator,
    TAccountCreatorAta,
    TAccountRecipient,
    TAccountSender,
    TAccountNftCollectionData,
    TAccountNftCollectionMasterEdition,
    TAccountNftCollectionMetadata,
    TAccountNftCollectionMint,
    TAccountDepositTokenMint,
    TAccountStreamNftMint,
    TAccountRecipientStreamNftAta,
    TAccountStreamData,
    TAccountStreamDataAta,
    TAccountStreamNftMasterEdition,
    TAccountStreamNftMetadata,
    TAccountAssociatedTokenProgram,
    TAccountDepositTokenProgram,
    TAccountNftTokenProgram,
    TAccountTokenMetadataProgram,
    TAccountSystemProgram,
    TAccountRent
  >);
}

export type CreateWithDurationsLlInput<
  TAccountCreator extends string = string,
  TAccountCreatorAta extends string = string,
  TAccountRecipient extends string = string,
  TAccountSender extends string = string,
  TAccountNftCollectionData extends string = string,
  TAccountNftCollectionMasterEdition extends string = string,
  TAccountNftCollectionMetadata extends string = string,
  TAccountNftCollectionMint extends string = string,
  TAccountDepositTokenMint extends string = string,
  TAccountStreamNftMint extends string = string,
  TAccountRecipientStreamNftAta extends string = string,
  TAccountStreamData extends string = string,
  TAccountStreamDataAta extends string = string,
  TAccountStreamNftMasterEdition extends string = string,
  TAccountStreamNftMetadata extends string = string,
  TAccountAssociatedTokenProgram extends string = string,
  TAccountDepositTokenProgram extends string = string,
  TAccountNftTokenProgram extends string = string,
  TAccountTokenMetadataProgram extends string = string,
  TAccountSystemProgram extends string = string,
  TAccountRent extends string = string,
> = {
  /** Write account: the creator and funder of the stream. */
  creator: TransactionSigner<TAccountCreator>;
  /** Write account: the creator's ATA for the deposit token. */
  creatorAta: Address<TAccountCreatorAta>;
  /** Read account: the recipient of the stream. */
  recipient: Address<TAccountRecipient>;
  /** Read account: the sender of the stream. */
  sender: Address<TAccountSender>;
  /** Write account: the NFT collection data storing the total supply. */
  nftCollectionData: Address<TAccountNftCollectionData>;
  /** Write account: the master edition account for the NFT collection. */
  nftCollectionMasterEdition: Address<TAccountNftCollectionMasterEdition>;
  /** Write account: the metadata account for the NFT collection. */
  nftCollectionMetadata: Address<TAccountNftCollectionMetadata>;
  /** Read account: the mint account for the NFT collection. */
  nftCollectionMint: Address<TAccountNftCollectionMint>;
  /** Read account: the mint account for the deposit token. */
  depositTokenMint: Address<TAccountDepositTokenMint>;
  /** Create account: the mint account for the stream NFT. */
  streamNftMint: Address<TAccountStreamNftMint>;
  /** Create account: the ATA for the stream NFT owned by the recipient. */
  recipientStreamNftAta: Address<TAccountRecipientStreamNftAta>;
  /** Create account: the account that will store the stream data. */
  streamData: Address<TAccountStreamData>;
  /** Create account: the ATA for deposit tokens owned by stream data account. */
  streamDataAta: Address<TAccountStreamDataAta>;
  /** Create account: the master edition account for the stream NFT. */
  streamNftMasterEdition: Address<TAccountStreamNftMasterEdition>;
  /** Create account: the metadata account for the stream NFT. */
  streamNftMetadata: Address<TAccountStreamNftMetadata>;
  /** Program account: the Associated Token program. */
  associatedTokenProgram?: Address<TAccountAssociatedTokenProgram>;
  /** Program account: the Token program of the deposit token. */
  depositTokenProgram: Address<TAccountDepositTokenProgram>;
  /** Program account: the Token program of the stream NFT. */
  nftTokenProgram: Address<TAccountNftTokenProgram>;
  /** Program account: the Token Metadata program. */
  tokenMetadataProgram?: Address<TAccountTokenMetadataProgram>;
  /** Program account: the System program. */
  systemProgram?: Address<TAccountSystemProgram>;
  /** Sysvar account: Rent. */
  rent?: Address<TAccountRent>;
  salt: CreateWithDurationsLlInstructionDataArgs['salt'];
  depositAmount: CreateWithDurationsLlInstructionDataArgs['depositAmount'];
  cliffDuration: CreateWithDurationsLlInstructionDataArgs['cliffDuration'];
  totalDuration: CreateWithDurationsLlInstructionDataArgs['totalDuration'];
  startUnlockAmount: CreateWithDurationsLlInstructionDataArgs['startUnlockAmount'];
  cliffUnlockAmount: CreateWithDurationsLlInstructionDataArgs['cliffUnlockAmount'];
  isCancelable: CreateWithDurationsLlInstructionDataArgs['isCancelable'];
};

export function getCreateWithDurationsLlInstruction<
  TAccountCreator extends string,
  TAccountCreatorAta extends string,
  TAccountRecipient extends string,
  TAccountSender extends string,
  TAccountNftCollectionData extends string,
  TAccountNftCollectionMasterEdition extends string,
  TAccountNftCollectionMetadata extends string,
  TAccountNftCollectionMint extends string,
  TAccountDepositTokenMint extends string,
  TAccountStreamNftMint extends string,
  TAccountRecipientStreamNftAta extends string,
  TAccountStreamData extends string,
  TAccountStreamDataAta extends string,
  TAccountStreamNftMasterEdition extends string,
  TAccountStreamNftMetadata extends string,
  TAccountAssociatedTokenProgram extends string,
  TAccountDepositTokenProgram extends string,
  TAccountNftTokenProgram extends string,
  TAccountTokenMetadataProgram extends string,
  TAccountSystemProgram extends string,
  TAccountRent extends string,
  TProgramAddress extends Address = typeof SABLIER_LOCKUP_PROGRAM_ADDRESS,
>(
  input: CreateWithDurationsLlInput<
    TAccountCreator,
    TAccountCreatorAta,
    TAccountRecipient,
    TAccountSender,
    TAccountNftCollectionData,
    TAccountNftCollectionMasterEdition,
    TAccountNftCollectionMetadata,
    TAccountNftCollectionMint,
    TAccountDepositTokenMint,
    TAccountStreamNftMint,
    TAccountRecipientStreamNftAta,
    TAccountStreamData,
    TAccountStreamDataAta,
    TAccountStreamNftMasterEdition,
    TAccountStreamNftMetadata,
    TAccountAssociatedTokenProgram,
    TAccountDepositTokenProgram,
    TAccountNftTokenProgram,
    TAccountTokenMetadataProgram,
    TAccountSystemProgram,
    TAccountRent
  >,
  config?: { programAddress?: TProgramAddress }
): CreateWithDurationsLlInstruction<
  TProgramAddress,
  TAccountCreator,
  TAccountCreatorAta,
  TAccountRecipient,
  TAccountSender,
  TAccountNftCollectionData,
  TAccountNftCollectionMasterEdition,
  TAccountNftCollectionMetadata,
  TAccountNftCollectionMint,
  TAccountDepositTokenMint,
  TAccountStreamNftMint,
  TAccountRecipientStreamNftAta,
  TAccountStreamData,
  TAccountStreamDataAta,
  TAccountStreamNftMasterEdition,
  TAccountStreamNftMetadata,
  TAccountAssociatedTokenProgram,
  TAccountDepositTokenProgram,
  TAccountNftTokenProgram,
  TAccountTokenMetadataProgram,
  TAccountSystemProgram,
  TAccountRent
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? SABLIER_LOCKUP_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    creator: { value: input.creator ?? null, isWritable: true },
    creatorAta: { value: input.creatorAta ?? null, isWritable: true },
    recipient: { value: input.recipient ?? null, isWritable: false },
    sender: { value: input.sender ?? null, isWritable: false },
    nftCollectionData: {
      value: input.nftCollectionData ?? null,
      isWritable: true,
    },
    nftCollectionMasterEdition: {
      value: input.nftCollectionMasterEdition ?? null,
      isWritable: false,
    },
    nftCollectionMetadata: {
      value: input.nftCollectionMetadata ?? null,
      isWritable: true,
    },
    nftCollectionMint: {
      value: input.nftCollectionMint ?? null,
      isWritable: false,
    },
    depositTokenMint: {
      value: input.depositTokenMint ?? null,
      isWritable: false,
    },
    streamNftMint: { value: input.streamNftMint ?? null, isWritable: true },
    recipientStreamNftAta: {
      value: input.recipientStreamNftAta ?? null,
      isWritable: true,
    },
    streamData: { value: input.streamData ?? null, isWritable: true },
    streamDataAta: { value: input.streamDataAta ?? null, isWritable: true },
    streamNftMasterEdition: {
      value: input.streamNftMasterEdition ?? null,
      isWritable: true,
    },
    streamNftMetadata: {
      value: input.streamNftMetadata ?? null,
      isWritable: true,
    },
    associatedTokenProgram: {
      value: input.associatedTokenProgram ?? null,
      isWritable: false,
    },
    depositTokenProgram: {
      value: input.depositTokenProgram ?? null,
      isWritable: false,
    },
    nftTokenProgram: {
      value: input.nftTokenProgram ?? null,
      isWritable: false,
    },
    tokenMetadataProgram: {
      value: input.tokenMetadataProgram ?? null,
      isWritable: false,
    },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.tokenMetadataProgram.value) {
    accounts.tokenMetadataProgram.value =
      'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s' as Address<'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s'>;
  }
  if (!accounts.associatedTokenProgram.value) {
    accounts.associatedTokenProgram.value =
      'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address<'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'>;
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }
  if (!accounts.rent.value) {
    accounts.rent.value =
      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.creator),
      getAccountMeta(accounts.creatorAta),
      getAccountMeta(accounts.recipient),
      getAccountMeta(accounts.sender),
      getAccountMeta(accounts.nftCollectionData),
      getAccountMeta(accounts.nftCollectionMasterEdition),
      getAccountMeta(accounts.nftCollectionMetadata),
      getAccountMeta(accounts.nftCollectionMint),
      getAccountMeta(accounts.depositTokenMint),
      getAccountMeta(accounts.streamNftMint),
      getAccountMeta(accounts.recipientStreamNftAta),
      getAccountMeta(accounts.streamData),
      getAccountMeta(accounts.streamDataAta),
      getAccountMeta(accounts.streamNftMasterEdition),
      getAccountMeta(accounts.streamNftMetadata),
      getAccountMeta(accounts.associatedTokenProgram),
      getAccountMeta(accounts.depositTokenProgram),
      getAccountMeta(accounts.nftTokenProgram),
      getAccountMeta(accounts.tokenMetadataProgram),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent),
    ],
    data: getCreateWithDurationsLlInstructionDataEncoder().encode(
      args as CreateWithDurationsLlInstructionDataArgs
    ),
    programAddress,
  } as CreateWithDurationsLlInstruction<
    TProgramAddress,
    TAccountCreator,
    TAccountCreatorAta,
    TAccountRecipient,
    TAccountSender,
    TAccountNftCollectionData,
    TAccountNftCollectionMasterEdition,
    TAccountNftCollectionMetadata,
    TAccountNftCollectionMint,
    TAccountDepositTokenMint,
    TAccountStreamNftMint,
    TAccountRecipientStreamNftAta,
    TAccountStreamData,
    TAccountStreamDataAta,
    TAccountStreamNftMasterEdition,
    TAccountStreamNftMetadata,
    TAccountAssociatedTokenProgram,
    TAccountDepositTokenProgram,
    TAccountNftTokenProgram,
    TAccountTokenMetadataProgram,
    TAccountSystemProgram,
    TAccountRent
  >);
}

export type ParsedCreateWithDurationsLlInstruction<
  TProgram extends string = typeof SABLIER_LOCKUP_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    /** Write account: the creator and funder of the stream. */
    creator: TAccountMetas[0];
    /** Write account: the creator's ATA for the deposit token. */
    creatorAta: TAccountMetas[1];
    /** Read account: the recipient of the stream. */
    recipient: TAccountMetas[2];
    /** Read account: the sender of the stream. */
    sender: TAccountMetas[3];
    /** Write account: the NFT collection data storing the total supply. */
    nftCollectionData: TAccountMetas[4];
    /** Write account: the master edition account for the NFT collection. */
    nftCollectionMasterEdition: TAccountMetas[5];
    /** Write account: the metadata account for the NFT collection. */
    nftCollectionMetadata: TAccountMetas[6];
    /** Read account: the mint account for the NFT collection. */
    nftCollectionMint: TAccountMetas[7];
    /** Read account: the mint account for the deposit token. */
    depositTokenMint: TAccountMetas[8];
    /** Create account: the mint account for the stream NFT. */
    streamNftMint: TAccountMetas[9];
    /** Create account: the ATA for the stream NFT owned by the recipient. */
    recipientStreamNftAta: TAccountMetas[10];
    /** Create account: the account that will store the stream data. */
    streamData: TAccountMetas[11];
    /** Create account: the ATA for deposit tokens owned by stream data account. */
    streamDataAta: TAccountMetas[12];
    /** Create account: the master edition account for the stream NFT. */
    streamNftMasterEdition: TAccountMetas[13];
    /** Create account: the metadata account for the stream NFT. */
    streamNftMetadata: TAccountMetas[14];
    /** Program account: the Associated Token program. */
    associatedTokenProgram: TAccountMetas[15];
    /** Program account: the Token program of the deposit token. */
    depositTokenProgram: TAccountMetas[16];
    /** Program account: the Token program of the stream NFT. */
    nftTokenProgram: TAccountMetas[17];
    /** Program account: the Token Metadata program. */
    tokenMetadataProgram: TAccountMetas[18];
    /** Program account: the System program. */
    systemProgram: TAccountMetas[19];
    /** Sysvar account: Rent. */
    rent: TAccountMetas[20];
  };
  data: CreateWithDurationsLlInstructionData;
};

export function parseCreateWithDurationsLlInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>
): ParsedCreateWithDurationsLlInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 21) {
    // TODO: Coded error.
    throw new Error('Not enough accounts');
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      creator: getNextAccount(),
      creatorAta: getNextAccount(),
      recipient: getNextAccount(),
      sender: getNextAccount(),
      nftCollectionData: getNextAccount(),
      nftCollectionMasterEdition: getNextAccount(),
      nftCollectionMetadata: getNextAccount(),
      nftCollectionMint: getNextAccount(),
      depositTokenMint: getNextAccount(),
      streamNftMint: getNextAccount(),
      recipientStreamNftAta: getNextAccount(),
      streamData: getNextAccount(),
      streamDataAta: getNextAccount(),
      streamNftMasterEdition: getNextAccount(),
      streamNftMetadata: getNextAccount(),
      associatedTokenProgram: getNextAccount(),
      depositTokenProgram: getNextAccount(),
      nftTokenProgram: getNextAccount(),
      tokenMetadataProgram: getNextAccount(),
      systemProgram: getNextAccount(),
      rent: getNextAccount(),
    },
    data: getCreateWithDurationsLlInstructionDataDecoder().decode(
      instruction.data
    ),
  };
}
